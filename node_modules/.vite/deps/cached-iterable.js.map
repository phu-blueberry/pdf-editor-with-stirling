{
  "version": 3,
  "sources": ["../../cached-iterable/src/cached_iterable.mjs", "../../cached-iterable/src/cached_sync_iterable.mjs", "../../cached-iterable/src/cached_async_iterable.mjs"],
  "sourcesContent": ["/*\n * Base CachedIterable class.\n */\nexport default class CachedIterable extends Array {\n    /**\n     * Create a `CachedIterable` instance from an iterable or, if another\n     * instance of `CachedIterable` is passed, return it without any\n     * modifications.\n     *\n     * @param {Iterable} iterable\n     * @returns {CachedIterable}\n     */\n    static from(iterable) {\n        if (iterable instanceof this) {\n            return iterable;\n        }\n\n        return new this(iterable);\n    }\n}\n", "import CachedIterable from \"./cached_iterable.mjs\";\n\n/*\n * CachedSyncIterable caches the elements yielded by an iterable.\n *\n * It can be used to iterate over an iterable many times without depleting the\n * iterable.\n */\nexport default class CachedSyncIterable extends CachedIterable {\n    /**\n     * Create an `CachedSyncIterable` instance.\n     *\n     * @param {Iterable} iterable\n     * @returns {CachedSyncIterable}\n     */\n    constructor(iterable) {\n        super();\n\n        if (Symbol.iterator in Object(iterable)) {\n            this.iterator = iterable[Symbol.iterator]();\n        } else {\n            throw new TypeError(\"Argument must implement the iteration protocol.\");\n        }\n    }\n\n    [Symbol.iterator]() {\n        const cached = this;\n        let cur = 0;\n\n        return {\n            next() {\n                if (cached.length <= cur) {\n                    cached.push(cached.iterator.next());\n                }\n                return cached[cur++];\n            }\n        };\n    }\n\n    /**\n     * This method allows user to consume the next element from the iterator\n     * into the cache.\n     *\n     * @param {number} count - number of elements to consume\n     */\n    touchNext(count = 1) {\n        let idx = 0;\n        while (idx++ < count) {\n            const last = this[this.length - 1];\n            if (last && last.done) {\n                break;\n            }\n            this.push(this.iterator.next());\n        }\n        // Return the last cached {value, done} object to allow the calling\n        // code to decide if it needs to call touchNext again.\n        return this[this.length - 1];\n    }\n}\n", "import CachedIterable from \"./cached_iterable.mjs\";\n\n/*\n * CachedAsyncIterable caches the elements yielded by an async iterable.\n *\n * It can be used to iterate over an iterable many times without depleting the\n * iterable.\n */\nexport default class CachedAsyncIterable extends CachedIterable {\n    /**\n     * Create an `CachedAsyncIterable` instance.\n     *\n     * @param {Iterable} iterable\n     * @returns {CachedAsyncIterable}\n     */\n    constructor(iterable) {\n        super();\n\n        if (Symbol.asyncIterator in Object(iterable)) {\n            this.iterator = iterable[Symbol.asyncIterator]();\n        } else if (Symbol.iterator in Object(iterable)) {\n            this.iterator = iterable[Symbol.iterator]();\n        } else {\n            throw new TypeError(\"Argument must implement the iteration protocol.\");\n        }\n    }\n\n    /**\n     * Asynchronous iterator caching the yielded elements.\n     *\n     * Elements yielded by the original iterable will be cached and available\n     * synchronously. Returns an async generator object implementing the\n     * iterator protocol over the elements of the original (async or sync)\n     * iterable.\n     */\n    [Symbol.asyncIterator]() {\n        const cached = this;\n        let cur = 0;\n\n        return {\n            async next() {\n                if (cached.length <= cur) {\n                    cached.push(cached.iterator.next());\n                }\n                return cached[cur++];\n            }\n        };\n    }\n\n    /**\n     * This method allows user to consume the next element from the iterator\n     * into the cache.\n     *\n     * @param {number} count - number of elements to consume\n     */\n    async touchNext(count = 1) {\n        let idx = 0;\n        while (idx++ < count) {\n            const last = this[this.length - 1];\n            if (last && (await last).done) {\n                break;\n            }\n            this.push(this.iterator.next());\n        }\n        // Return the last cached {value, done} object to allow the calling\n        // code to decide if it needs to call touchNext again.\n        return this[this.length - 1];\n    }\n}\n"],
  "mappings": ";;;AAGA,IAAqB,iBAArB,cAA4C,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAS9C,OAAO,KAAK,UAAU;AAClB,QAAI,oBAAoB,MAAM;AAC1B,aAAO;AAAA,IACX;AAEA,WAAO,IAAI,KAAK,QAAQ;AAAA,EAC5B;AACJ;;;ACXA,IAAqB,qBAArB,cAAgD,eAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAO3D,YAAY,UAAU;AAClB,UAAM;AAEN,QAAI,OAAO,YAAY,OAAO,QAAQ,GAAG;AACrC,WAAK,WAAW,SAAS,OAAO,QAAQ,EAAE;AAAA,IAC9C,OAAO;AACH,YAAM,IAAI,UAAU,iDAAiD;AAAA,IACzE;AAAA,EACJ;AAAA,EAEA,CAAC,OAAO,QAAQ,IAAI;AAChB,UAAM,SAAS;AACf,QAAI,MAAM;AAEV,WAAO;AAAA,MACH,OAAO;AACH,YAAI,OAAO,UAAU,KAAK;AACtB,iBAAO,KAAK,OAAO,SAAS,KAAK,CAAC;AAAA,QACtC;AACA,eAAO,OAAO,KAAK;AAAA,MACvB;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,UAAU,QAAQ,GAAG;AACjB,QAAI,MAAM;AACV,WAAO,QAAQ,OAAO;AAClB,YAAM,OAAO,KAAK,KAAK,SAAS,CAAC;AACjC,UAAI,QAAQ,KAAK,MAAM;AACnB;AAAA,MACJ;AACA,WAAK,KAAK,KAAK,SAAS,KAAK,CAAC;AAAA,IAClC;AAGA,WAAO,KAAK,KAAK,SAAS,CAAC;AAAA,EAC/B;AACJ;;;AClDA,IAAqB,sBAArB,cAAiD,eAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAO5D,YAAY,UAAU;AAClB,UAAM;AAEN,QAAI,OAAO,iBAAiB,OAAO,QAAQ,GAAG;AAC1C,WAAK,WAAW,SAAS,OAAO,aAAa,EAAE;AAAA,IACnD,WAAW,OAAO,YAAY,OAAO,QAAQ,GAAG;AAC5C,WAAK,WAAW,SAAS,OAAO,QAAQ,EAAE;AAAA,IAC9C,OAAO;AACH,YAAM,IAAI,UAAU,iDAAiD;AAAA,IACzE;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,CAAC,OAAO,aAAa,IAAI;AACrB,UAAM,SAAS;AACf,QAAI,MAAM;AAEV,WAAO;AAAA,MACH,MAAM,OAAO;AACT,YAAI,OAAO,UAAU,KAAK;AACtB,iBAAO,KAAK,OAAO,SAAS,KAAK,CAAC;AAAA,QACtC;AACA,eAAO,OAAO,KAAK;AAAA,MACvB;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,UAAU,QAAQ,GAAG;AACvB,QAAI,MAAM;AACV,WAAO,QAAQ,OAAO;AAClB,YAAM,OAAO,KAAK,KAAK,SAAS,CAAC;AACjC,UAAI,SAAS,MAAM,MAAM,MAAM;AAC3B;AAAA,MACJ;AACA,WAAK,KAAK,KAAK,SAAS,KAAK,CAAC;AAAA,IAClC;AAGA,WAAO,KAAK,KAAK,SAAS,CAAC;AAAA,EAC/B;AACJ;",
  "names": []
}
